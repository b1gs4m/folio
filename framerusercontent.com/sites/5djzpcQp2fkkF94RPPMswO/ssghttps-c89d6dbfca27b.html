// Code from Nikolay Goncharuk on GitHub: // https://github.com/GoncharukBro/react-smart-masonry/blob/master/src/Masonry.tsx // https://github.com/GoncharukBro/react-smart-masonry/blob/master/src/useResize.ts // // Modified by Isaac Roberts for Superfields
// https://superfields.io // // Copyright (c) 2021 Nikolay Goncharuk // MIT License import{jsx as _jsx}from"react/jsx-runtime";import{useState,useLayoutEffect,useEffect,useMemo,useRef,Children,isValidElement}from"react";const DEFAULT_COLUMNS=1;const DEFAULT_GAP=0;export
default function Masonry({breakpoints,columns=DEFAULT_COLUMNS,gapH=DEFAULT_GAP,gapV=DEFAULT_GAP,reverse=false,autoArrange=false,alignment="center",children,style,...otherProps},forwardedRef){const elements=useRef([]);const previousLayout=useRef([]);const[arrange,setArrange]=useState(false);const[layoutVersion,setLayoutVersion]=useState(0);const
resizeObservers=useRef(new Map);const updateTimeoutRef=useRef(null);const earliestChangedIndex=useRef(null);// Replace image load handler with resize observer handler const handleElementResize=element=>{if(!resizeObservers.current.has(element)){let lastUpdatedHeight=element.offsetHeight;const
observer=new ResizeObserver(entries=>{const entry=entries[0];const newHeight=entry.target.offsetHeight;if(newHeight!==lastUpdatedHeight&&Math.abs(newHeight-lastUpdatedHeight)>2){lastUpdatedHeight=newHeight;// Find the index of the changed element const
changedIndex=elements.current.findIndex(el=>el.element===element);// Update earliest changed index if(earliestChangedIndex.current===null){earliestChangedIndex.current=changedIndex;}else{earliestChangedIndex.current=Math.min(earliestChangedIndex.current,changedIndex);}//
Only set timeout if one isn't already running if(!updateTimeoutRef.current){const delay=layoutVersion===0?10:200// 10ms for first update, 200ms for subsequent ;updateTimeoutRef.current=setTimeout(()=>{setLayoutVersion(v=>v+1);updateTimeoutRef.current=null;},delay);}}});observer.observe(element);resizeObservers.current.set(element,observer);}};const
addElement=index=>element=>{if(element!==null){temporaryElements.push({element,index});elements.current=temporaryElements;handleElementResize(element);}};// Cleanup resize observers when component unmounts useEffect(()=>{return()=>{resizeObservers.current.forEach(observer=>observer.disconnect());resizeObservers.current.clear();};},[]);//
Clean up timeout on unmount useEffect(()=>{return()=>{if(updateTimeoutRef.current){clearTimeout(updateTimeoutRef.current);}};},[]);useLayoutEffect(()=>{if(autoArrange&&!arrange)setArrange(true);if(autoArrange&&arrange)setLayoutVersion(v=>v+1);return()=>{if(autoArrange&&arrange)setArrange(false);};},[autoArrange]);const
layout=useMemo(()=>{if(columns
<1)return[];const arrayOfChildren=Children.toArray(children);if(reverse)arrayOfChildren.reverse();const newLayout=Array.from({length:columns},()=>{return[];});const columnHeights=newLayout.map(()=>0);var _earliestChangedIndex_current;// Use the ref directly instead of parsing from layoutVersion const changedIndex=(_earliestChangedIndex_current=earliestChangedIndex.current)!==null&&_earliestChangedIndex_current!==void
    0?_earliestChangedIndex_current:-1;const getColumnIndex=index=>{if(autoArrange&&arrange&&elements.current.length>0){// If we're after the changed element, find the shortest column if(changedIndex===-1||index>changedIndex){const columnIndex=columnHeights.findIndex(item=>{return
    item===Math.min(...columnHeights);});const element=elements.current.find(item=>item.index===index);const elementHeight=element===null||element===void 0?void 0:element.element.getBoundingClientRect().height;columnHeights[columnIndex]+=(elementHeight||0)+gapV;return
    columnIndex;}else{// For elements before or at the changed index, use their current column const element=elements.current.find(item=>item.index===index);if(element){const currentColumn=previousLayout.current.findIndex(col=>col.some(item=>item.index===index));if(currentColumn!==-1){const
    elementHeight=element.element.getBoundingClientRect().height;columnHeights[currentColumn]+=(elementHeight||0)+gapV;return currentColumn;}}// Fallback to default behavior if element not found const columnIndex=columnHeights.findIndex(item=>{return
    item===Math.min(...columnHeights);});const elementHeight=element===null||element===void 0?void 0:element.element.getBoundingClientRect().height;columnHeights[columnIndex]+=(elementHeight||0)+gapV;return columnIndex;}}return index%columns;};arrayOfChildren.forEach((child,index)=>{if(child&&/*#__PURE__*/isValidElement(child)){newLayout[getColumnIndex(index)].push({element:child,index});}});//
    Store the new layout for next render previousLayout.current=newLayout;return newLayout;},[layoutVersion,arrange,children,columns,reverse,autoArrange]);const temporaryElements=[];return /*#__PURE__*/_jsx("div",{ref:forwardedRef,style:{display:"flex",gap:gapH,...style},...otherProps,children:layout.map((column,columnIndex)=>/*#__PURE__*/_jsx("div",{style:{flex:1,display:"flex",flexDirection:"column",alignItems:alignment,gap:gapV},children:column.map((item,itemIndex)=>/*#__PURE__*/_jsx("div",{ref:addElement(item.index),children:item.element},itemIndex))},columnIndex))});}Masonry.displayName="Superfields/Masonry";
    export const __FramerMetadata__ = {"exports":{"default":{"type":"reactComponent","name":"Masonry","slots":["children"],"annotations":{"framerContractVersion":"1"}},"MasonryProps":{"type":"tsType","annotations":{"framerContractVersion":"1"}},"__FramerMetadata__":{"type":"variable"}}}
    //# sourceMappingURL=./Masonry.map