/** * Accepts a string, and returns true/false if the string is in ISO 8601 format with the option of adding "Z" at the end. * @param {string} str - A string representing a date in ISO 8601 format. * @returns {boolean} - Returns true if str is in ISO
8601 format, otherwise returns false. */export function isISO8601(str){const isoDateRegex=/^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}(\.\d+)?(Z|([+-]\d{2}:\d{2}))?$/;return isoDateRegex.test(str);}/** * Accepts a text, checks to see if it's in ISO 8601 format,
if yes, resets the time and returns ISO 8601 string, otherwise return empty string. * @param {string} text - Date as a string in ISO 8601 format. * @returns {string} - Returns the same string value with the time cleared or an empty string. */export function
resetTimeOfISODateString(text){return isISO8601(text)?`${text.substring(0,10)}T00:00:00.000Z`:"";}export function getProps({object,target,returnParent=false}){if(!object||!target.name||!target.type)return undefined;const propMatch=object[target.name];const
typeMatch=target.type.toLowerCase()==="array"?Array.isArray(propMatch):typeof propMatch===target.type.toLowerCase();if(propMatch&&typeMatch){// return the target or the target's parent (which will contain the target) return returnParent?object:propMatch;}for(let
nestedProp in object){const value=object[nestedProp];// don't go down another level if the value is not of type object/array if(typeof value!=="object")continue;const result=getProps({returnParent,target,object:value});if(result!==undefined)return result;}}export
function getAllCollections({queryFrom,referencedCollections={}}){if(!queryFrom)return false;const{constraint,left,right,type}=queryFrom;if(type==="Collection"){referencedCollections[queryFrom.alias]={...queryFrom};}getAllCollections({queryFrom:queryFrom.left,referencedCollections});getAllCollections({queryFrom:queryFrom.right,referencedCollections});return
referencedCollections;}// the most basic of nodes, mostly used for literal value comparisons export function createBinaryOperationNode({left,right,operator}){return{left,right,operator,type:"BinaryOperation"};}// used for enum/option CMS field types export
function createCaseNode({controlId,optionIds}){const createCondition=optionId=>{return{then:{type:"LiteralValue",value:true},type:"Condition",when:{type:"LiteralValue",value:optionId}};};return{type:"Case",conditions:optionIds.map(createCondition),else:{type:"LiteralValue",value:false},value:{name:controlId,type:"Identifier"}};}//
used for string fields where the condition includes 'starts_with', 'ends_with', or 'contains' export function createFunctionCallNode({binaryNode,functionName}){return{functionName,arguments:[binaryNode.left,binaryNode.right],type:"FunctionCall"};}// wraps
a node to negate its value export function createUnaryOperationNode({value}){return{operator:"not",type:"UnaryOperation",value};}export function handleCondition_IsIncludedIn({collection,condition,name,type,value}){// check if the filter condition is for
the negated value const negateValue=condition.charAt(0)==="!";const node=createBinaryOperationNode({left:{collection,name,type},right:{value,type:"LiteralValue"},operator:"in"});// if the value needs to be negated, wrap the node in a unary operation return
negateValue?createUnaryOperationNode({value:node}):node;}/** * Handles filters with conditions as "IS_SET" or "!IS_SET". * @param {object} controlIdentifier - An object representing the control, composed of * {collection, name, type} properties. * @param
{string} condition - The string defining the type of filtering condition. * @returns {object} - Returns a binary operation node or unary operation node if the value is negated. */export function handleCondition_IsSet({collection,name,type,condition}){//
check if the filter condition is for the negated value const negateValue=condition.charAt(0)==="!";const left=createBinaryOperationNode({operator:"!=",left:{collection,name,type},right:{value:null,type:"LiteralValue"}});const right=createBinaryOperationNode({operator:"!=",left:{collection,name,type},right:{value:"",type:"LiteralValue"}});const
node=createBinaryOperationNode({left,right,operator:"and"});// if the value needs to be negated, wrap the node in a unary operation return negateValue?createUnaryOperationNode({value:node}):node;}/** * Handles filters with conditions as "STARTS_WITH",
"!STARTS_WITH", "ENDS_WITH", "!ENDS_WITH", "CONTAINS", "!CONTAINS". * @param {object} controlIdentifier - An object representing the control, composed of * {collection, name, type} properties. * @param {string} condition - The string defining the type
of filtering condition. * @returns {object} - Returns a binary operation node or unary operation node if the value is negated. */export function handleCondition_StartsWith_EndsWith_Contains({controlIdentifier,condition,value}){// check if the filter condition
is for the negated value const negateValue=condition.charAt(0)==="!";// Framer uses filter functions in their query tree for "STARTS_WITH", "ENDS_WITH", or "CONTAINS" const functionName=negateValue?condition.substring(1):condition;const node=createFunctionCallNode({binaryNode:createBinaryOperationNode({left:controlIdentifier,right:{value,type:"LiteralValue"},operator:"=="}),functionName});//
if the value needs to be negated, wrap the node in a unary operation return negateValue?createUnaryOperationNode({value:node}):node;}/** * Parses a string representing a range * @param {string} rangeString - String formatted to represent a range. * @returns
{object} - Returns an object with the start and end values, and if they're inclusive or exclusive. */export function parseRangeCondition({rangeString}){// inclusive: // greater than or equal: [ // lesser than or equal: ] //exclusive: // greater than:
( // lesser than: ) // check the first character to determine if the condition is "greater than", or "greater than or equal" const startOperator=rangeString.charAt(0)==="["?">=":">";// check the last character to determine if the condition is "lesser
than", or "lesser than or equal" const endOperator=rangeString.charAt(rangeString.length-1)==="]"?"<=":" < ";// ommit the first and last charaters to split the values
const ranges=rangeString.substring(1,rangeString.length-1).split(", ");return{start:{operator:startOperator,value:ranges[0]},end:{operator:endOperator,value:ranges[1]}};}/**
 * Handles filters with conditions that contains the substring "IS_BETWEEN ".
 * @param {object} controlIdentifier - An object with properties of the control.
 * @param {object} start - The starting value and operator of the range.
 * @param {object} end - The ending value and operator of the range.
 * @returns {object} - Returns a binary operation node.
 */export function handleCondition_IsBetween({controlIdentifier,start,end}){const left=createBinaryOperationNode({left:controlIdentifier,right:{value:start.value,type:"LiteralValue "},operator:start.operator});// the results will be less than or equal to this end
const right=createBinaryOperationNode({left:controlIdentifier,right:{value:end.value,type:"LiteralValue "},operator:end.operator});return createBinaryOperationNode({left,right,operator:"and "});}// returns the tree structure used by Framer to apply filters to collection list
export function createFramerFilterTree({nodes=[],operator="and "}){let tree={};nodes.forEach((node,index)=>{if(index===0){tree=node;}else{tree={operator,left:tree,right:node,type:"BinaryOperation "};}});return tree;}
export const __FramerMetadata__ = {"exports ":{"handleCondition_IsBetween ":{"type ":"function ","annotations ":{"framerContractVersion ":"1 "}},"resetTimeOfISODateString ":{"type ":"function ","annotations ":{"framerContractVersion ":"1 "}},"getProps
    ":{"type ":"function ","annotations ":{"framerContractVersion ":"1 "}},"handleCondition_StartsWith_EndsWith_Contains ":{"type ":"function ","annotations ":{"framerContractVersion ":"1 "}},"isISO8601 ":{"type ":"function ","annotations ":{"framerContractVersion
    ":"1 "}},"createCaseNode ":{"type ":"function ","annotations ":{"framerContractVersion ":"1 "}},"createBinaryOperationNode ":{"type ":"function ","annotations ":{"framerContractVersion ":"1 "}},"createUnaryOperationNode ":{"type ":"function ","annotations
    ":{"framerContractVersion ":"1 "}},"createFramerFilterTree ":{"type ":"function ","annotations ":{"framerContractVersion ":"1 "}},"getAllCollections ":{"type ":"function ","annotations ":{"framerContractVersion ":"1 "}},"createFunctionCallNode ":{"type
    ":"function ","annotations ":{"framerContractVersion ":"1 "}},"parseRangeCondition ":{"type ":"function ","annotations ":{"framerContractVersion ":"1 "}},"handleCondition_IsIncludedIn ":{"type ":"function ","annotations ":{"framerContractVersion ":"1
    "}},"handleCondition_IsSet ":{"type ":"function ","annotations ":{"framerContractVersion ":"1 "}},"__FramerMetadata__ ":{"type ":"variable "}}}
//# sourceMappingURL=./Utilities.map