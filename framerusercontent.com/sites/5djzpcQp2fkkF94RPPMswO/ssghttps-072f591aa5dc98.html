// @ts-ignore import{useQueryData,useIsOnFramerCanvas}from"framer";import{useState,useEffect,useRef,useMemo}from"react";import{useStore,useDevStore}from"https://framerusercontent.com/modules/oaAH7umUjUOTeKmykfom/4GSr51yWhuxjuWu6QpOf/Stores.js";import{getProps,getAllCollections,createFramerFilterTree,createBinaryOperationNode,createCaseNode,createFunctionCallNode,createUnaryOperationNode,handleCondition_IsBetween,handleCondition_IsIncludedIn,handleCondition_IsSet,handleCondition_StartsWith_EndsWith_Contains,parseRangeCondition}from"https://framerusercontent.com/modules/NktNXvnf4m4T7jKQcOHx/ld1Thy4iHs6v3180zPrJ/Utilities.js";/**
* Hook that prints to the console when debugging CMS Plus. * @param {boolean} debug - Is debugging CMS Plus or not. * * @returns {object} - An object with the following properties: * @param {function} consoleLogWhenDebuggingCMSPlus - Function that acts
just like console.log, but only when debugging CMS Plus. */export const useConsoleLogWhenDebuggingCMSPlus=()=>{const[store]=useDevStore();const consoleLogWhenDebuggingCMSPlus=(...args)=>{if(store.isDebugging)console.log(...args);};return{consoleLogWhenDebuggingCMSPlus};};export
const useGetFramerCMSItems=query=>{const[items,setItem]=useState([]);useEffect(()=>{if(!!query){const extractedItems=useQueryData(query);setItem(extractedItems);}},[query]);return items;};/** * Hook to debounce a value. * @param {number} delay - The delay
in milliseconds before the debounced value is returned. Default is 2000. * @param {any} value - The value to debounce; the hook will return this value only after the specified delay without changes. * @returns {any} - Returns the debounced value after
the delay. */export const useDebouncer=({delay,value})=>{const[debouncedValue,setDebouncedValue]=useState(value);useEffect(()=>{const ID=setTimeout(()=>{setDebouncedValue(value);},delay);return()=>clearTimeout(ID);},[value]);return debouncedValue;};/**
* Hook to manage error alerts with a customizable delay. * @param {object} options - Configuration options for the hook. * @param {number} [options.delay=2000] - Optional delay in milliseconds before showing the alert. Defaults to 2000 if not provided.
* @returns {object} - An object with the following properties: * @property {string[]} addMessage - An array of text messages representing the current error messages. * @property {boolean} hasMessages - A boolean indicating if there are any error messages.
*/export const useAlert=({delay=2e3}={})=>{const isOnFramerCanvas=useIsOnFramerCanvas();const[messages,setMessages]=useState([]);const debouncedMessages=useDebouncer({delay,value:messages});const addMessage=message=>{if(!isOnFramerCanvas)setMessages(prev=>[...prev,message]);};const
clearMessages=()=>{if(!isOnFramerCanvas)setMessages([]);};useEffect(()=>{if(debouncedMessages.length>0)alert(` Error! ${debouncedMessages.join("\n")}`);},[debouncedMessages]);return{addMessage,clearMessages,hasMessages:messages.length>0};};/** * Custom
hook that uses the cmsPlus collection's active filters to construct Framer's collection query where object. * @param {string} collectionID - The id of the collection stored in cmsPlus store. * @returns {function} Returns the where object structures as
Framer's filtering tree to be used within the colleciton list query. */export const useConstructFramerCollectionQueryWhere=({collectionID})=>{const{consoleLogWhenDebuggingCMSPlus}=useConsoleLogWhenDebuggingCMSPlus();const[store]=useStore();const collection=store[collectionID];//
get the current collection's props const alias=collection?.alias||"";const fields=collection?.fields||{};const realTimeSearch=collection?.realTimeSearch||null;const collectionReferences=collection?.collectionReferences||null;// every element stores Framer's
query filter structure made up of all the filters for that CMS field, // 'branches' will looped throught and formatted into the same Framer query filter structure const branches=[];// if there is a search text, loop through the selected CMS fields and
create a Framer query tree joined with "or" logic. // this is the only time were different CMS field are joined as "match any" logic if(!!realTimeSearch&&realTimeSearch.text!==""){const nodes=[];// gather all the fields to search in and remove any duplicates
const realTimeSearchFields=Array.from(new Set(realTimeSearch.fields));realTimeSearchFields.forEach(fieldName=>{// if the field does not exist in the CMS, skip if(!fields.hasOwnProperty(fieldName))return;const control=fields[fieldName];const{type}=control;const
controlIdentifier={collection:alias,name:control.id,type:"Identifier"};if(type==="string"){nodes.push(createFunctionCallNode({binaryNode:createBinaryOperationNode({left:controlIdentifier,right:{value:realTimeSearch.text,type:"LiteralValue"},operator:"=="}),functionName:"CONTAINS"}));}});if(nodes.length>0)branches.push(createFramerFilterTree({nodes,operator:"or"}));}//
loop through each CMS field, for each active filter create a node, store in 'nodes', then format the 'nodes' into Framer's query filter structure with 'or' logic for(const[name,props]of Object.entries(fields)){// @ts-ignore const{id,type,options,optionTitles,filters}=props;//
required for building the Framer query where object // collection alias is what collection this field is derived from // id is the Framer identification for this field control const controlIdentifier={collection:alias,name:id,type:"Identifier"};const
nodes=[];filters?.forEach((activeFilter,currentFilterIndex,theseFilters)=>{const{condition,value,isActive}=activeFilter;// handle the active filter based on CMS field type switch(type){case"enum":// enum/option CMS field type is different. it does not
need to loop through each active filter. // all possible options are gathered, and if theres one active filter, then a binary operation node is pushed into nodes, otherwise, more than 1 active filter uses a case note instead. if(currentFilterIndex>0)return;//
cross reference the filter values to their corresponding Framer control IDs const activeFilterOptionIds=theseFilters.filter(thisFilter=>thisFilter.isActive).map(thisFilter=>{const index=optionTitles.indexOf(thisFilter.value);return options[index];});if(activeFilterOptionIds.length
<1)return;//
    use a binary operation node for 1 active filter, otherwise, for more active filters, use a case node nodes.push(theseFilters.length===1?createBinaryOperationNode({left:controlIdentifier,right:{value:activeFilterOptionIds[0],type: "LiteralValue"},operator:activeFilter.condition}):createCaseNode({controlId:id,optionIds:activeFilterOptionIds}));break;case
    "slug":case "string":// skip if the filter is inactive if(!isActive)return;// handles when the condition is "Equals" or "Doesn't Equal" if(condition=="==" ||condition=="!=" ){nodes.push(createBinaryOperationNode({left:controlIdentifier,right:{value,type:
    "LiteralValue"},operator:condition}));// handles when the condition is "IS_SET" or "!IS_SET" }else if(condition.includes( "IS_SET")){nodes.push(handleCondition_IsSet({...controlIdentifier,condition}));// handles filters with conditions as "STARTS_WITH",
    "!STARTS_WITH", "ENDS_WITH", "!ENDS_WITH", "CONTAINS", or "!CONTAINS" }else if(condition.includes( "STARTS_WITH")||condition.includes( "ENDS_WITH")||condition.includes( "CONTAINS")){nodes.push(handleCondition_StartsWith_EndsWith_Contains({controlIdentifier,condition,value}));}break;case
    "number":// skip if the filter is inactive if(!isActive)return;if(condition==="IS_BETWEEN_NUMBERS" ){const range=parseRangeCondition({rangeString:value});const start={value:Number(range.start.value),operator:range.start.operator};const end={value:Number(range.end.value),operator:range.end.operator};nodes.push(handleCondition_IsBetween({controlIdentifier,start,end}));}else{//
    handles single values nodes.push(createBinaryOperationNode({left:controlIdentifier,right:{value,type: "LiteralValue"},operator:condition}));}break;case "date":// skip if the filter is inactive if(!isActive)return;if(condition==="IS_BETWEEN_DATES" ){const
    range=parseRangeCondition({rangeString:value});const start={value:range.start.value,operator:range.start.operator};const end={value:range.end.value,operator:range.end.operator};nodes.push(handleCondition_IsBetween({controlIdentifier,start,end}));}else{//
    handles single dates nodes.push(createBinaryOperationNode({left:controlIdentifier,right:{value,type: "LiteralValue"},operator:condition}));}break;case "file":case "richtext":case "responsiveimage":case "link":// skip if the filter is inactive if(!isActive)return;nodes.push(handleCondition_IsSet({...controlIdentifier,condition}));break;case
    "boolean":// skip if the filter is inactive if(!isActive)return;nodes.push(activeFilter.value?controlIdentifier:createUnaryOperationNode({value:controlIdentifier}));break;case "collectionreference":// skip if the filter is inactive if(!isActive)return;// for
    references, the referenced collection alias is used as this field control 's id, and the name is replaced with 'id '
const collectionIdentifier={...controlIdentifier,collection:id,name:"id"};if(condition.includes("IS_SET")){nodes.push(handleCondition_IsSet({...collectionIdentifier,condition}));}if(condition=="=="||condition=="!="){nodes.push(createBinaryOperationNode({left:collectionIdentifier,right:{value,type:"LiteralValue"},operator:condition}));}if(condition.includes("IS_INCLUDED")){nodes.push(handleCondition_IsIncludedIn({...collectionIdentifier,condition,value}));}break;case"multicollectionreference":// skip of the filter is inactive
if(!isActive)return;// get the multi referenced collection
const argument=collectionReferences[value];if(condition.includes("CONTAINS")){// check if the filter condition is for the negated value
const negateValue=condition.charAt(0)==="!";const node=createBinaryOperationNode({left:{value,type:"LiteralValue"},right:{arguments:[argument],functionName:"FLAT_ARRAY",type:"FunctionCall"},operator:"in"});nodes.push(negateValue?createUnaryOperationNode({value:node}):node);}break;// do nothing if the control is not supported
default:consoleLogWhenDebuggingCMSPlus("🆇:",`CMS field ${type} type is not supported.`);break;}});// every node will be used to construct Framer's query tree joined with "or" logic. // this will allow filters from the same CMS fields applied as
    "match any" logic. if(nodes.length>0)branches.push(createFramerFilterTree({nodes,operator:"or"}));}// every branch will be used to construct Framer's query tree joined with "and" logic. // this will allow filters from different CMS fields applied as "match all" logic. const where=createFramerFilterTree({nodes:branches,operator:"and"});return()=>Object.keys(where).length>0?where:null;};export
    const useFramerCollectionList=({collectionPlusID,framerCollectionList,isDebugging=false})=>{// stores const[store,setStore]=useStore();const[devStore,setDevStore]=useDevStore();// states // key for updating the collection list on the page, a change
    will trigger a render const[key,setKey]=useState(0);const[noSearchResults,setNoSearchResults]=useState(false);const[collection,setCollection]=useState({alias:null,id:null,name:null,query:null});// local variables const collectionInitializedInStore=!!store[collection.id];const
    sortDirection=store[collection.id]?.sort;const debounced_delay=250;// hooks const isOnFramerCanvas=useIsOnFramerCanvas();const constructFramerCollectionQueryWhere=useConstructFramerCollectionQueryWhere({collectionID:collection.id});// any dependencies
    that can trigger the render key should be debounced to prevent collection list flicker const fields_debounced=useDebouncer({delay:debounced_delay,value:store[collection.id]?.fields});const searchText_debounced=useDebouncer({delay:debounced_delay,value:store[collection.id]?.realTimeSearch.text});const
    framerCollectionList_debounced=useDebouncer({delay:debounced_delay,value:framerCollectionList});// in order to extract cms query data, the cmsPlus filters will need to be formatted into Framer's query where tree structure and applied to query const
    searchResults=useMemo(()=>{if(!!fields_debounced&&!!collection.query){const where=constructFramerCollectionQueryWhere();const orderBy=collection.query?.orderBy||null;// by default, sort is ascending when orberBy is undefined, and is not neede if(!!orderBy&&!!sortDirection){if(isDebugging){console.log("↕️:",`Setting
    ${sortDirection} order.`);}collection.query.orderBy[0]={...collection.query.orderBy[0],direction:sortDirection};}if(!!where){if(isDebugging)console.log("🈸:",where);collection.query.where=where;}else{delete collection.query.where;}if(isDebugging){console.log("🟠:","Query:",Object.assign({},collection.query));}return
    useQueryData(collection.query);}return null;},[fields_debounced,sortDirection,!!collection.query,searchText_debounced,framerCollectionList]);// updates the collection store with cms items, updates the render key for the collection list, and updates
    if the noSearchResults frame shoule be shown useEffect(()=>{/** * at this point: * 1. framerCollectionList has been validated * 2. the collection has been stored * 3. its query has been altered by applying CMS+ filters * 4. the cms items (query data)
    has been extracted using the altered query * 5. finally the collection list on the page needs to be updated by changing the render key */if(!!searchResults){if(isDebugging){console.log("🟢:",`Updating CMS Items: id# ${collection.id} || name ${collection.name}
    || item count ${searchResults.length}`);}const noResults=searchResults.length
    <1;// key=0 signifies the collection list is updating on Collection+ // this avoids a split-second double render when switching from no results --> results until the collection list is updated with the latest filters const updatedKey=noResults?0:Math.floor(Math.random()*1e5);setNoSearchResults(noResults);setKey(updatedKey);setStore(prev=>({...prev,[collection.id]:{...prev[collection.id],searchResults}}));}},[collectionInitializedInStore,sortDirection,fields_debounced,searchText_debounced,framerCollectionList_debounced]);//
        when on Preview/Live view only // if collection is not set in store, initialize a valid Framer collection list in store // otherwise, if it's the same list, sync the stored collection to Collection+ useEffect(()=>{if(!isOnFramerCanvas){if(isDebugging){console.log("🛠️:","CMS
        Plus debugging enabled...");console.log("");}// get the query object from the Framer collection list // if a query object does not exist, then the linked frame is not a valid Framer collection list instance const query=getProps({object:framerCollectionList,target:{name:"query",type:"object"}});//
        for Framer collection lists not using any references, this will return query.from // otherwise, list using references, it will return query.from.left const props=getProps({object:query,target:{name:"alias",type:"string"},returnParent:true});//
        get the name of the collection // for collections that include references, multiple collections will be in the query object, but the first one is the target const name=getProps({object:props,target:{name:"displayName",type:"string"}});// initialize
        in store if(!!name&&!!query){const storedCollection=store[collectionPlusID];if(!storedCollection){if(isDebugging){console.log("✅:",`Initializing Collection+: "${name}" with id# ${collectionPlusID} in store.`);console.log("🟠:","Query:",Object.assign({},query));}//
        these are any native Framer filters applied on the list via the canvas const defaultFilters=getProps({object:query,target:{name:"where",type:"object"}});// make the cms fields easier to manage by having the object props by readable titles, rather
        than its Framer ID const cmsFieldsByID=getProps({object:props,target:{name:"propertyControls",type:"object"}});const cmsFieldsByName={};for(const[controlID,field]of Object.entries(cmsFieldsByID)){// @ts-ignore const{title,...otherProps}=field;cmsFieldsByName[title]={...otherProps,id:controlID};}const
        from=getProps({object:query,target:{name:"from",type:"object"}});// if this collection list includes reference CMS fields, then gather all collections and remove the current one to be left the referenced collections only const allCollections=getAllCollections({queryFrom:from});delete
        allCollections[props?.alias];const collectionReferences=Object.keys(allCollections).length>0?allCollections:null;if(isDebugging&&collectionReferences){console.log("🟠:","References:",collectionReferences);}// initiate the collection in store if
        valid setStore(prev=>({...prev,[collectionPlusID]:{...defaultFilters&&{defaultFilters},...collectionReferences&&{collectionReferences},name,alias:props?.alias,fields:cmsFieldsByName,realTimeSearch:{fields:[],text:""},searchResults:[]}}));}else{if(isDebugging){console.log("🟩:",`Syncing
        Collection+ from store: id#${storedCollection.id} "${storedCollection.name}"`);}if(name===storedCollection.name){if(collection.query?.where){query.where=collection.query.where;}}}}// store query from a valid Framer collection list setCollection({name,alias:props?.alias,id:collectionPlusID,...!!query&&{query}});//
        always start off with a 0 key, this notifies Collection+ the list is not ready and do not show setKey(0);// cmsPlus collection+ must have props._cmsPlusDebugging = true via an override setDevStore(prev=>({...prev,isDebugging}));}},[isOnFramerCanvas,framerCollectionList]);if(isDebugging)console.log("📀:",Object.assign({},store));return{key,noSearchResults};};/**
        * Accesses a collection from the store using its ID. * * @param {string} collectionID - The collection's unique ID. * @returns {Object} - * - `isCollectionReady`: True if the collection exists and the view is not on Framer Canvas. * - `collectionFromStore`:
        The collection data or null if not found. */export const useCollectionFromStore=collectionID=>{const[store,setStore]=useStore();const collection=store[collectionID]||null;const isOnFramerCanvas=useIsOnFramerCanvas();return{isCollectionReady:!isOnFramerCanvas&&!!collection,collectionFromStore:collection};};/**
        * Validates the Filter+ component for CMS Plus. * Ensures the collection, field, and value are valid based on the given conditions. * * @param {string} collectionID - The ID of the CMS collection to validate. * @param {string} controlType - The
        expected control type of the field (e.g., 'string', 'number'). * @param {string} cmsFieldName - The name of the CMS field to validate. * @param {*} value - The value being checked; must not be undefined if required. * @param {boolean} valueIsRequired
        - Whether a value is required (true) or not (false). * * @returns {boolean} - Returns true if the filter is valid; otherwise, false. */export const useIsFilter_Valid=({collectionID,controlType,cmsFieldName,value,valueIsRequired})=>{const{consoleLogWhenDebuggingCMSPlus}=useConsoleLogWhenDebuggingCMSPlus();const[isFilter_Valid,setIsFilter_Valid]=useState(false);const{isCollectionReady,collectionFromStore}=useCollectionFromStore(collectionID);const
        supportedControlTypes=["boolean","collectionreference","date","enum","file","link","multicollectionreference","number","responsiveimage","richtext","string"];// Validate the filter when collection or related dependencies change useEffect(()=>{setIsFilter_Valid(false)//
        Reset filter validity on dependency changes ;if(isCollectionReady){const field=collectionFromStore.fields[cmsFieldName];const isSupportedType=supportedControlTypes.includes(field?.type);const usingMatchingFilterType=field?.type===controlType;const
        value_isValid=valueIsRequired?value!==undefined// Value must not be undefined if required :value===null// For optional values, null is acceptable ;if(!!field&&isSupportedType&&usingMatchingFilterType&&value_isValid){setIsFilter_Valid(true)// Mark
        filter as valid ;}else{const errors=[`❗️ Invalid Filter+ for ${cmsFieldName}:`];if(!field)errors.push(`${cmsFieldName} does not exist.`);if(!isSupportedType)errors.push(`${!!field?field.type:`Field`} type is not supported.`);if(!usingMatchingFilterType)errors.push("Using
        the wrong type of Filter+ for CMS field.");if(value===undefined)errors.push("Value is required.");consoleLogWhenDebuggingCMSPlus(errors.join("\n"));}}},[isCollectionReady,cmsFieldName,value,valueIsRequired]);return isFilter_Valid// Returns whether
        the filter is valid ;};/** * Hook to initialize a filter in the collection store. * * Ensures that the specified filter is added to the store when valid and handles * clean-up or reset logic for non-preserved filters. * * Arguments: * @param {string}
        cmsFieldName - The CMS field to apply the filter to. * @param {string} collectionID - The ID of the collection this filter belongs to. * @param {string} condition - The filter's condition (e.g., "equals"). * @param {string} controlType - The type
        of control (e.g., toggle, dropdown). * @param {boolean} isFilterActive - Whether the filter is currently active. * @param {boolean} isFilter_Valid - Indicates if the filter is valid for initialization. * @param {boolean} isPreserving - Whether
        the filter should be preserved on page reload. * @param {*} value - The value the filter applies. * * Returns: * - `isFilter_Initialized`: True if the filter is already initialized. * - `isFilter_CurrentlyActive`: The active status of the filter
        or null if uninitialized. */export const useInitializeFilter=({cmsFieldName,collectionID,condition,controlType,isFilterActive,isFilter_Valid,isPreserving,value})=>{const{consoleLogWhenDebuggingCMSPlus}=useConsoleLogWhenDebuggingCMSPlus();const
        setStore=useStore()[1];// Store default values for the filter to detect overrides. const defaultValues_Ref=useRef({cmsFieldName,collectionID,condition,isPreserving,value});const{collectionFromStore}=useCollectionFromStore(collectionID);// Check
        if the filter is already initialized in the collection store. const initializedFilter=collectionFromStore?.fields?.[cmsFieldName]?.filters?.find(f=>f.condition===condition&&(f.value===value||JSON.stringify(f.value)===JSON.stringify(value)))??null;const
        isFilterActive_defaultRef=useRef(isFilterActive);const isFilterActive_Ref=useRef(isFilterActive);const isFilter_Initialized_Ref=useRef(!!initializedFilter);// Keep track of filter active state. useEffect(()=>{isFilterActive_Ref.current=isFilterActive;},[isFilterActive]);//
        Initialize the filter in the collection store if it is valid and not already initialized. useEffect(()=>{if(isFilter_Valid&&!initializedFilter){consoleLogWhenDebuggingCMSPlus(`✅ Initializing Filter+: id# ${collectionID} | field ${cmsFieldName}
        | type ${controlType} | condition ${condition} | value ${value} | active? ${isFilterActive}`);isFilter_Initialized_Ref.current=true;setStore(prev=>{const prevFilters=prev[collectionID]?.fields[cmsFieldName]?.filters??[];return{...prev,[collectionID]:{...prev[collectionID],fields:{...prev[collectionID]?.fields,[cmsFieldName]:{...prev[collectionID]?.fields[cmsFieldName],filters:[...prevFilters,{condition,value,isActive:isFilterActive}]}}}};});}//
        Clean up: handle overrides if default values have changed. return()=>{const currentValues={cmsFieldName,collectionID,condition,isPreserving,value};const hasOverrides=Object.keys(currentValues).some(key=>{const currentValue=currentValues[key];const
        defaultValue=defaultValues_Ref.current[key];consoleLogWhenDebuggingCMSPlus(`Hooks > ${defaultValues_Ref.current.cmsFieldName}:`);consoleLogWhenDebuggingCMSPlus(`Hooks > Current Value:`,currentValue);consoleLogWhenDebuggingCMSPlus(`Hooks > Default
        Value:`,defaultValue);if(typeof defaultValue==="object"){return JSON.stringify(currentValue)!==JSON.stringify(defaultValue);}return currentValue!==defaultValue;});if(isFilter_Valid&&hasOverrides){const{cmsFieldName:prevCMSFieldName,collectionID:prevCollectionID,condition:prevCondition,value:prevValue}=defaultValues_Ref.current;consoleLogWhenDebuggingCMSPlus(`🆑
        Clean Up Filter+: id# ${prevCollectionID} | field ${prevCMSFieldName} | type ${controlType} | condition ${prevCondition} | value ${prevValue}`);setStore(prev=>{const prevFilters=prev[prevCollectionID]?.fields[prevCMSFieldName]?.filters??[];return{...prev,[prevCollectionID]:{...prev[prevCollectionID],fields:{...prev[prevCollectionID]?.fields,[prevCMSFieldName]:{...prev[prevCollectionID]?.fields[prevCMSFieldName],filters:prevFilters.filter(f=>f.condition!==prevCondition||f.value!==prevValue)}}}};});}Object.assign(defaultValues_Ref.current,currentValues);};},[isFilter_Valid,cmsFieldName,collectionID,condition,isPreserving,value]);//
        Reset filters that are not preserved to their default state. useEffect(()=>{return()=>{if(isFilter_Initialized_Ref.current&&!defaultValues_Ref.current.isPreserving){if(isFilterActive_Ref.current!==isFilterActive_defaultRef.current){const{cmsFieldName,collectionID,condition,value}=defaultValues_Ref.current;consoleLogWhenDebuggingCMSPlus(`🟨
        Resetting Filter+: id# ${collectionID} | field ${cmsFieldName} | type ${controlType} | condition ${condition} | value ${value}`);setStore(prev=>{const prevFilters=prev[collectionID]?.fields[cmsFieldName]?.filters??[];return{...prev,[collectionID]:{...prev[collectionID],fields:{...prev[collectionID]?.fields,[cmsFieldName]:{...prev[collectionID]?.fields[cmsFieldName],filters:prevFilters.map(f=>f.condition===condition&&f.value===value?{...f,isActive:isFilterActive_defaultRef.current}:f)}}}};});}}};},[]);return{isFilter_Initialized:!!initializedFilter,isFilter_CurrentlyActive:initializedFilter?.isActive??null};};/**
        * Custom hook to sync a component's variant with its stored state. * * Arguments: * @param {boolean} component_isReady - Indicates if the component is ready for synchronization. * @param {function} debuggingLog - Logs debug information during
        synchronization. * @param {boolean} desynchronized - True if the component state differs from the stored state. * @param {boolean} isPreserving - Enables synchronization when state preservation is active. * @param {*} remoteValue - The value representing
        changes from an external source. * @param {function} transitionToVariant - Triggers a transition to the correct variant. * * Returns: * @returns {object} - `{ checkVariantSync }`, a flag indicating if the synchronization check is in progress.
        */export const useVariantSync=({component_isReady,debuggingLog,desynchronized,isPreserving,remoteValue,transitionToVariant})=>{const[checkVariantSync,setCheckVariantSync]=useState(isPreserving);// Sync to the correct variant when the component
        is ready and preserving state. useEffect(()=>{if(component_isReady){if(isPreserving&&desynchronized){debuggingLog();transitionToVariant?.();}// Mark the synchronization check as completed. setCheckVariantSync(false);}},[component_isReady]);//
        Handle changes from an external source. useEffect(()=>{if(desynchronized&&!checkVariantSync){debuggingLog();transitionToVariant?.();}},[remoteValue]);return{checkVariantSync};};export const useFilter=({cmsPlusComponentName,collectionID,condition,value,cmsFieldName,isPreserving,isFilterActive,interactionActiveFilter,interactionInactiveFilter,controlType,valueIsRequired})=>{const{consoleLogWhenDebuggingCMSPlus}=useConsoleLogWhenDebuggingCMSPlus();const
        setStore=useStore()[1];const isFilterActive_defaultRef=useRef(isFilterActive);// Step 1: Validate the filter configuration. const isFilter_Valid=useIsFilter_Valid({collectionID,controlType,cmsFieldName,valueIsRequired,value});// Step 2: Initialize
        the filter with its default state if not already done. const{isFilter_Initialized,isFilter_CurrentlyActive}=useInitializeFilter({cmsFieldName,collectionID,condition,controlType,isFilterActive,isFilter_Valid,isPreserving,value});// compares the
        current active status with what is in the collection store const desynchronized=isFilterActive!==isFilter_CurrentlyActive;// wait for the component to be ready, then check if the variant needs to be synced const{checkVariantSync}=useVariantSync({desynchronized,isPreserving,component_isReady:isFilter_Initialized,remoteValue:isFilter_CurrentlyActive,debuggingLog:()=>consoleLogWhenDebuggingCMSPlus(`🔄
        Syncing Filter+ to ${isFilter_CurrentlyActive?"active":"inactive"} variant: id# ${collectionID} | field ${cmsFieldName} | type ${controlType} | condition ${condition} | value ${value}`),transitionToVariant:isFilter_CurrentlyActive?interactionActiveFilter:interactionInactiveFilter});const
        isFilterActive_Debounced=useDebouncer({delay:200,value:isFilterActive});useEffect(()=>{if(isFilter_Initialized&&desynchronized&&!checkVariantSync){setStore(prev=>({...prev,[collectionID]:{...prev[collectionID],fields:{...prev[collectionID]?.fields,[cmsFieldName]:{...prev[collectionID]?.fields?.[cmsFieldName],filters:prev[collectionID]?.fields?.[cmsFieldName]?.filters?.map(f=>{if(f.condition===condition&&(f.value===value||JSON.stringify(f.value)===JSON.stringify(value))){return{...f,isActive:isFilterActive};}return
        f;})}}}}));consoleLogWhenDebuggingCMSPlus(`🟨 ${isFilterActive?"Activating":"Deactivating"} Filter+`,cmsFieldName,condition,value,`for id# ${collectionID}.`);}},[isFilter_Initialized,isFilterActive_Debounced,checkVariantSync]);};export const useReferencedCMSIds=()=>{const[store]=useStore();console.log("reference
        cms ids >",store);}; export const __FramerMetadata__ = {"exports":{"useConstructFramerCollectionQueryWhere":{"type":"variable","annotations":{"framerContractVersion":"1"}},"useDebouncer":{"type":"variable","annotations":{"framerContractVersion":"1"}},"useCollectionFromStore":{"type":"variable","annotations":{"framerContractVersion":"1"}},"useGetFramerCMSItems":{"type":"variable","annotations":{"framerContractVersion":"1"}},"useAlert":{"type":"variable","annotations":{"framerContractVersion":"1"}},"useFilter":{"type":"variable","annotations":{"framerContractVersion":"1"}},"useConsoleLogWhenDebuggingCMSPlus":{"type":"variable","annotations":{"framerContractVersion":"1"}},"useIsFilter_Valid":{"type":"variable","annotations":{"framerContractVersion":"1"}},"useFramerCollectionList":{"type":"variable","annotations":{"framerContractVersion":"1"}},"useInitializeFilter":{"type":"variable","annotations":{"framerContractVersion":"1"}},"useVariantSync":{"type":"variable","annotations":{"framerContractVersion":"1"}},"useReferencedCMSIds":{"type":"variable","annotations":{"framerContractVersion":"1"}},"__FramerMetadata__":{"type":"variable"}}}